/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.tonapi.models.GetAllRawShardsInfo200Response
import io.tonapi.models.GetOutMsgQueueSizes200Response
import io.tonapi.models.GetRawAccountState200Response
import io.tonapi.models.GetRawBlockProof200Response
import io.tonapi.models.GetRawBlockchainBlock200Response
import io.tonapi.models.GetRawBlockchainBlockHeader200Response
import io.tonapi.models.GetRawBlockchainBlockState200Response
import io.tonapi.models.GetRawConfig200Response
import io.tonapi.models.GetRawListBlockTransactions200Response
import io.tonapi.models.GetRawMasterchainInfo200Response
import io.tonapi.models.GetRawMasterchainInfoExt200Response
import io.tonapi.models.GetRawShardBlockProof200Response
import io.tonapi.models.GetRawShardInfo200Response
import io.tonapi.models.GetRawTime200Response
import io.tonapi.models.GetRawTransactions200Response
import io.tonapi.models.SendRawMessage200Response
import io.tonapi.models.SendRawMessageRequest
import io.tonapi.models.StatusDefaultResponse

import com.squareup.moshi.Json

import io.tonapi.infrastructure.ApiClient
import io.tonapi.infrastructure.ApiResponse
import io.tonapi.infrastructure.ClientException
import io.tonapi.infrastructure.ClientError
import io.tonapi.infrastructure.ServerException
import io.tonapi.infrastructure.ServerError
import io.tonapi.infrastructure.MultiValueMap
import io.tonapi.infrastructure.PartConfig
import io.tonapi.infrastructure.RequestConfig
import io.tonapi.infrastructure.RequestMethod
import io.tonapi.infrastructure.ResponseType
import io.tonapi.infrastructure.Success
import io.tonapi.infrastructure.toMultiValue

class LiteServerApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    /**
     * 
     * Get all raw shards info
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return GetAllRawShardsInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAllRawShardsInfo(blockId: kotlin.String) : GetAllRawShardsInfo200Response {
        val localVarResponse = getAllRawShardsInfoWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAllRawShardsInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all raw shards info
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return ApiResponse<GetAllRawShardsInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllRawShardsInfoWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetAllRawShardsInfo200Response?> {
        val localVariableConfig = getAllRawShardsInfoRequestConfig(blockId = blockId)

        return request<Unit, GetAllRawShardsInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllRawShardsInfo
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return RequestConfig
     */
    fun getAllRawShardsInfoRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_all_shards_info/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get out msg queue sizes
     * @return GetOutMsgQueueSizes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOutMsgQueueSizes() : GetOutMsgQueueSizes200Response {
        val localVarResponse = getOutMsgQueueSizesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOutMsgQueueSizes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get out msg queue sizes
     * @return ApiResponse<GetOutMsgQueueSizes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOutMsgQueueSizesWithHttpInfo() : ApiResponse<GetOutMsgQueueSizes200Response?> {
        val localVariableConfig = getOutMsgQueueSizesRequestConfig()

        return request<Unit, GetOutMsgQueueSizes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOutMsgQueueSizes
     *
     * @return RequestConfig
     */
    fun getOutMsgQueueSizesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_out_msg_queue_sizes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw account state
     * @param accountId account ID
     * @param targetBlock target block: (workchain,shard,seqno,root_hash,file_hash) (optional)
     * @return GetRawAccountState200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawAccountState(accountId: kotlin.String, targetBlock: kotlin.String? = null) : GetRawAccountState200Response {
        val localVarResponse = getRawAccountStateWithHttpInfo(accountId = accountId, targetBlock = targetBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawAccountState200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw account state
     * @param accountId account ID
     * @param targetBlock target block: (workchain,shard,seqno,root_hash,file_hash) (optional)
     * @return ApiResponse<GetRawAccountState200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawAccountStateWithHttpInfo(accountId: kotlin.String, targetBlock: kotlin.String?) : ApiResponse<GetRawAccountState200Response?> {
        val localVariableConfig = getRawAccountStateRequestConfig(accountId = accountId, targetBlock = targetBlock)

        return request<Unit, GetRawAccountState200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawAccountState
     *
     * @param accountId account ID
     * @param targetBlock target block: (workchain,shard,seqno,root_hash,file_hash) (optional)
     * @return RequestConfig
     */
    fun getRawAccountStateRequestConfig(accountId: kotlin.String, targetBlock: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (targetBlock != null) {
                    put("target_block", listOf(targetBlock.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_account_state/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw block proof
     * @param knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @param targetBlock target block: (workchain,shard,seqno,root_hash,file_hash) (optional)
     * @return GetRawBlockProof200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockProof(knownBlock: kotlin.String, mode: kotlin.Int, targetBlock: kotlin.String? = null) : GetRawBlockProof200Response {
        val localVarResponse = getRawBlockProofWithHttpInfo(knownBlock = knownBlock, mode = mode, targetBlock = targetBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockProof200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw block proof
     * @param knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @param targetBlock target block: (workchain,shard,seqno,root_hash,file_hash) (optional)
     * @return ApiResponse<GetRawBlockProof200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockProofWithHttpInfo(knownBlock: kotlin.String, mode: kotlin.Int, targetBlock: kotlin.String?) : ApiResponse<GetRawBlockProof200Response?> {
        val localVariableConfig = getRawBlockProofRequestConfig(knownBlock = knownBlock, mode = mode, targetBlock = targetBlock)

        return request<Unit, GetRawBlockProof200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawBlockProof
     *
     * @param knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @param targetBlock target block: (workchain,shard,seqno,root_hash,file_hash) (optional)
     * @return RequestConfig
     */
    fun getRawBlockProofRequestConfig(knownBlock: kotlin.String, mode: kotlin.Int, targetBlock: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("known_block", listOf(knownBlock.toString()))
                if (targetBlock != null) {
                    put("target_block", listOf(targetBlock.toString()))
                }
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_block_proof",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw blockchain block
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return GetRawBlockchainBlock200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainBlock(blockId: kotlin.String) : GetRawBlockchainBlock200Response {
        val localVarResponse = getRawBlockchainBlockWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockchainBlock200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw blockchain block
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return ApiResponse<GetRawBlockchainBlock200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainBlockWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetRawBlockchainBlock200Response?> {
        val localVariableConfig = getRawBlockchainBlockRequestConfig(blockId = blockId)

        return request<Unit, GetRawBlockchainBlock200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawBlockchainBlock
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return RequestConfig
     */
    fun getRawBlockchainBlockRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_block/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw blockchain block header
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @return GetRawBlockchainBlockHeader200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainBlockHeader(blockId: kotlin.String, mode: kotlin.Int) : GetRawBlockchainBlockHeader200Response {
        val localVarResponse = getRawBlockchainBlockHeaderWithHttpInfo(blockId = blockId, mode = mode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockchainBlockHeader200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw blockchain block header
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @return ApiResponse<GetRawBlockchainBlockHeader200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainBlockHeaderWithHttpInfo(blockId: kotlin.String, mode: kotlin.Int) : ApiResponse<GetRawBlockchainBlockHeader200Response?> {
        val localVariableConfig = getRawBlockchainBlockHeaderRequestConfig(blockId = blockId, mode = mode)

        return request<Unit, GetRawBlockchainBlockHeader200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawBlockchainBlockHeader
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @return RequestConfig
     */
    fun getRawBlockchainBlockHeaderRequestConfig(blockId: kotlin.String, mode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_block_header/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw blockchain block state
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return GetRawBlockchainBlockState200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainBlockState(blockId: kotlin.String) : GetRawBlockchainBlockState200Response {
        val localVarResponse = getRawBlockchainBlockStateWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockchainBlockState200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw blockchain block state
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return ApiResponse<GetRawBlockchainBlockState200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainBlockStateWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetRawBlockchainBlockState200Response?> {
        val localVariableConfig = getRawBlockchainBlockStateRequestConfig(blockId = blockId)

        return request<Unit, GetRawBlockchainBlockState200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawBlockchainBlockState
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return RequestConfig
     */
    fun getRawBlockchainBlockStateRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_state/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw config
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @return GetRawConfig200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawConfig(blockId: kotlin.String, mode: kotlin.Int) : GetRawConfig200Response {
        val localVarResponse = getRawConfigWithHttpInfo(blockId = blockId, mode = mode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawConfig200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw config
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @return ApiResponse<GetRawConfig200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawConfigWithHttpInfo(blockId: kotlin.String, mode: kotlin.Int) : ApiResponse<GetRawConfig200Response?> {
        val localVariableConfig = getRawConfigRequestConfig(blockId = blockId, mode = mode)

        return request<Unit, GetRawConfig200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawConfig
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @return RequestConfig
     */
    fun getRawConfigRequestConfig(blockId: kotlin.String, mode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_config_all/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw list block transactions
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @param count count
     * @param accountId account ID (optional)
     * @param lt lt (optional)
     * @return GetRawListBlockTransactions200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawListBlockTransactions(blockId: kotlin.String, mode: kotlin.Int, count: kotlin.Int, accountId: kotlin.String? = null, lt: kotlin.Long? = null) : GetRawListBlockTransactions200Response {
        val localVarResponse = getRawListBlockTransactionsWithHttpInfo(blockId = blockId, mode = mode, count = count, accountId = accountId, lt = lt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawListBlockTransactions200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw list block transactions
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @param count count
     * @param accountId account ID (optional)
     * @param lt lt (optional)
     * @return ApiResponse<GetRawListBlockTransactions200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawListBlockTransactionsWithHttpInfo(blockId: kotlin.String, mode: kotlin.Int, count: kotlin.Int, accountId: kotlin.String?, lt: kotlin.Long?) : ApiResponse<GetRawListBlockTransactions200Response?> {
        val localVariableConfig = getRawListBlockTransactionsRequestConfig(blockId = blockId, mode = mode, count = count, accountId = accountId, lt = lt)

        return request<Unit, GetRawListBlockTransactions200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawListBlockTransactions
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param mode mode
     * @param count count
     * @param accountId account ID (optional)
     * @param lt lt (optional)
     * @return RequestConfig
     */
    fun getRawListBlockTransactionsRequestConfig(blockId: kotlin.String, mode: kotlin.Int, count: kotlin.Int, accountId: kotlin.String?, lt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
                put("count", listOf(count.toString()))
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (lt != null) {
                    put("lt", listOf(lt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/list_block_transactions/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw masterchain info
     * @return GetRawMasterchainInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawMasterchainInfo() : GetRawMasterchainInfo200Response {
        val localVarResponse = getRawMasterchainInfoWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawMasterchainInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw masterchain info
     * @return ApiResponse<GetRawMasterchainInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawMasterchainInfoWithHttpInfo() : ApiResponse<GetRawMasterchainInfo200Response?> {
        val localVariableConfig = getRawMasterchainInfoRequestConfig()

        return request<Unit, GetRawMasterchainInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawMasterchainInfo
     *
     * @return RequestConfig
     */
    fun getRawMasterchainInfoRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_masterchain_info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw masterchain info ext
     * @param mode mode
     * @return GetRawMasterchainInfoExt200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawMasterchainInfoExt(mode: kotlin.Int) : GetRawMasterchainInfoExt200Response {
        val localVarResponse = getRawMasterchainInfoExtWithHttpInfo(mode = mode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawMasterchainInfoExt200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw masterchain info ext
     * @param mode mode
     * @return ApiResponse<GetRawMasterchainInfoExt200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawMasterchainInfoExtWithHttpInfo(mode: kotlin.Int) : ApiResponse<GetRawMasterchainInfoExt200Response?> {
        val localVariableConfig = getRawMasterchainInfoExtRequestConfig(mode = mode)

        return request<Unit, GetRawMasterchainInfoExt200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawMasterchainInfoExt
     *
     * @param mode mode
     * @return RequestConfig
     */
    fun getRawMasterchainInfoExtRequestConfig(mode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_masterchain_info_ext",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw shard block proof
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return GetRawShardBlockProof200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawShardBlockProof(blockId: kotlin.String) : GetRawShardBlockProof200Response {
        val localVarResponse = getRawShardBlockProofWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawShardBlockProof200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw shard block proof
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return ApiResponse<GetRawShardBlockProof200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawShardBlockProofWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetRawShardBlockProof200Response?> {
        val localVariableConfig = getRawShardBlockProofRequestConfig(blockId = blockId)

        return request<Unit, GetRawShardBlockProof200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawShardBlockProof
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @return RequestConfig
     */
    fun getRawShardBlockProofRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_shard_block_proof/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw shard info
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param workchain workchain
     * @param shard shard
     * @param exact exact
     * @return GetRawShardInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawShardInfo(blockId: kotlin.String, workchain: kotlin.Int, shard: kotlin.Long, exact: kotlin.Boolean) : GetRawShardInfo200Response {
        val localVarResponse = getRawShardInfoWithHttpInfo(blockId = blockId, workchain = workchain, shard = shard, exact = exact)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawShardInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw shard info
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param workchain workchain
     * @param shard shard
     * @param exact exact
     * @return ApiResponse<GetRawShardInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawShardInfoWithHttpInfo(blockId: kotlin.String, workchain: kotlin.Int, shard: kotlin.Long, exact: kotlin.Boolean) : ApiResponse<GetRawShardInfo200Response?> {
        val localVariableConfig = getRawShardInfoRequestConfig(blockId = blockId, workchain = workchain, shard = shard, exact = exact)

        return request<Unit, GetRawShardInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawShardInfo
     *
     * @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param workchain workchain
     * @param shard shard
     * @param exact exact
     * @return RequestConfig
     */
    fun getRawShardInfoRequestConfig(blockId: kotlin.String, workchain: kotlin.Int, shard: kotlin.Long, exact: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("workchain", listOf(workchain.toString()))
                put("shard", listOf(shard.toString()))
                put("exact", listOf(exact.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_shard_info/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw time
     * @return GetRawTime200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawTime() : GetRawTime200Response {
        val localVarResponse = getRawTimeWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawTime200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw time
     * @return ApiResponse<GetRawTime200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawTimeWithHttpInfo() : ApiResponse<GetRawTime200Response?> {
        val localVariableConfig = getRawTimeRequestConfig()

        return request<Unit, GetRawTime200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawTime
     *
     * @return RequestConfig
     */
    fun getRawTimeRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_time",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw transactions
     * @param accountId account ID
     * @param count count
     * @param lt lt
     * @param hash hash
     * @return GetRawTransactions200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawTransactions(accountId: kotlin.String, count: kotlin.Int, lt: kotlin.Long, hash: kotlin.String) : GetRawTransactions200Response {
        val localVarResponse = getRawTransactionsWithHttpInfo(accountId = accountId, count = count, lt = lt, hash = hash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawTransactions200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw transactions
     * @param accountId account ID
     * @param count count
     * @param lt lt
     * @param hash hash
     * @return ApiResponse<GetRawTransactions200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawTransactionsWithHttpInfo(accountId: kotlin.String, count: kotlin.Int, lt: kotlin.Long, hash: kotlin.String) : ApiResponse<GetRawTransactions200Response?> {
        val localVariableConfig = getRawTransactionsRequestConfig(accountId = accountId, count = count, lt = lt, hash = hash)

        return request<Unit, GetRawTransactions200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawTransactions
     *
     * @param accountId account ID
     * @param count count
     * @param lt lt
     * @param hash hash
     * @return RequestConfig
     */
    fun getRawTransactionsRequestConfig(accountId: kotlin.String, count: kotlin.Int, lt: kotlin.Long, hash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("count", listOf(count.toString()))
                put("lt", listOf(lt.toString()))
                put("hash", listOf(hash.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_transactions/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Send raw message to blockchain
     * @param sendRawMessageRequest Data that is expected
     * @return SendRawMessage200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendRawMessage(sendRawMessageRequest: SendRawMessageRequest) : SendRawMessage200Response {
        val localVarResponse = sendRawMessageWithHttpInfo(sendRawMessageRequest = sendRawMessageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SendRawMessage200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Send raw message to blockchain
     * @param sendRawMessageRequest Data that is expected
     * @return ApiResponse<SendRawMessage200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendRawMessageWithHttpInfo(sendRawMessageRequest: SendRawMessageRequest) : ApiResponse<SendRawMessage200Response?> {
        val localVariableConfig = sendRawMessageRequestConfig(sendRawMessageRequest = sendRawMessageRequest)

        return request<SendRawMessageRequest, SendRawMessage200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendRawMessage
     *
     * @param sendRawMessageRequest Data that is expected
     * @return RequestConfig
     */
    fun sendRawMessageRequestConfig(sendRawMessageRequest: SendRawMessageRequest) : RequestConfig<SendRawMessageRequest> {
        val localVariableBody = sendRawMessageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/liteserver/send_message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
