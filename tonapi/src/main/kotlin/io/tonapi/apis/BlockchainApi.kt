/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.tonapi.models.BlockchainAccountInspect
import io.tonapi.models.BlockchainBlock
import io.tonapi.models.BlockchainBlockShards
import io.tonapi.models.BlockchainBlocks
import io.tonapi.models.BlockchainConfig
import io.tonapi.models.BlockchainRawAccount
import io.tonapi.models.MethodExecutionResult
import io.tonapi.models.RawBlockchainConfig
import io.tonapi.models.SendBlockchainMessageRequest
import io.tonapi.models.ServiceStatus
import io.tonapi.models.StatusDefaultResponse
import io.tonapi.models.Transaction
import io.tonapi.models.Transactions
import io.tonapi.models.Validators

import com.squareup.moshi.Json

import io.tonapi.infrastructure.ApiClient
import io.tonapi.infrastructure.ApiResponse
import io.tonapi.infrastructure.ClientException
import io.tonapi.infrastructure.ClientError
import io.tonapi.infrastructure.ServerException
import io.tonapi.infrastructure.ServerError
import io.tonapi.infrastructure.MultiValueMap
import io.tonapi.infrastructure.PartConfig
import io.tonapi.infrastructure.RequestConfig
import io.tonapi.infrastructure.RequestMethod
import io.tonapi.infrastructure.ResponseType
import io.tonapi.infrastructure.Success
import io.tonapi.infrastructure.toMultiValue

class BlockchainApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    /**
     * 
     * Blockchain account inspect
     * @param accountId account ID
     * @return BlockchainAccountInspect
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun blockchainAccountInspect(accountId: kotlin.String) : BlockchainAccountInspect {
        val localVarResponse = blockchainAccountInspectWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainAccountInspect
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Blockchain account inspect
     * @param accountId account ID
     * @return ApiResponse<BlockchainAccountInspect?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun blockchainAccountInspectWithHttpInfo(accountId: kotlin.String) : ApiResponse<BlockchainAccountInspect?> {
        val localVariableConfig = blockchainAccountInspectRequestConfig(accountId = accountId)

        return request<Unit, BlockchainAccountInspect>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation blockchainAccountInspect
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun blockchainAccountInspectRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}/inspect".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Execute get method for account
     * @param accountId account ID
     * @param methodName contract get method name
     * @param args  (optional)
     * @return MethodExecutionResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun execGetMethodForBlockchainAccount(accountId: kotlin.String, methodName: kotlin.String, args: kotlin.collections.List<kotlin.String>? = null) : MethodExecutionResult {
        val localVarResponse = execGetMethodForBlockchainAccountWithHttpInfo(accountId = accountId, methodName = methodName, args = args)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MethodExecutionResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Execute get method for account
     * @param accountId account ID
     * @param methodName contract get method name
     * @param args  (optional)
     * @return ApiResponse<MethodExecutionResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun execGetMethodForBlockchainAccountWithHttpInfo(accountId: kotlin.String, methodName: kotlin.String, args: kotlin.collections.List<kotlin.String>?) : ApiResponse<MethodExecutionResult?> {
        val localVariableConfig = execGetMethodForBlockchainAccountRequestConfig(accountId = accountId, methodName = methodName, args = args)

        return request<Unit, MethodExecutionResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation execGetMethodForBlockchainAccount
     *
     * @param accountId account ID
     * @param methodName contract get method name
     * @param args  (optional)
     * @return RequestConfig
     */
    fun execGetMethodForBlockchainAccountRequestConfig(accountId: kotlin.String, methodName: kotlin.String, args: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (args != null) {
                    put("args", toMultiValue(args.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}/methods/{method_name}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"method_name"+"}", encodeURIComponent(methodName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrderGetBlockchainAccountTransactions(val value: kotlin.String) {
         @Json(name = "desc") desc("desc"),
         @Json(name = "asc") asc("asc")
     }

    /**
     * 
     * Get account transactions
     * @param accountId account ID
     * @param afterLt omit this parameter to get last transactions (optional)
     * @param beforeLt omit this parameter to get last transactions (optional)
     * @param limit  (optional, default to 100)
     * @param sortOrder  (optional, default to desc)
     * @return Transactions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainAccountTransactions(accountId: kotlin.String, afterLt: kotlin.Long? = null, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = 100, sortOrder: SortOrderGetBlockchainAccountTransactions? = SortOrderGetBlockchainAccountTransactions.desc) : Transactions {
        val localVarResponse = getBlockchainAccountTransactionsWithHttpInfo(accountId = accountId, afterLt = afterLt, beforeLt = beforeLt, limit = limit, sortOrder = sortOrder)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get account transactions
     * @param accountId account ID
     * @param afterLt omit this parameter to get last transactions (optional)
     * @param beforeLt omit this parameter to get last transactions (optional)
     * @param limit  (optional, default to 100)
     * @param sortOrder  (optional, default to desc)
     * @return ApiResponse<Transactions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainAccountTransactionsWithHttpInfo(accountId: kotlin.String, afterLt: kotlin.Long?, beforeLt: kotlin.Long?, limit: kotlin.Int?, sortOrder: SortOrderGetBlockchainAccountTransactions?) : ApiResponse<Transactions?> {
        val localVariableConfig = getBlockchainAccountTransactionsRequestConfig(accountId = accountId, afterLt = afterLt, beforeLt = beforeLt, limit = limit, sortOrder = sortOrder)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainAccountTransactions
     *
     * @param accountId account ID
     * @param afterLt omit this parameter to get last transactions (optional)
     * @param beforeLt omit this parameter to get last transactions (optional)
     * @param limit  (optional, default to 100)
     * @param sortOrder  (optional, default to desc)
     * @return RequestConfig
     */
    fun getBlockchainAccountTransactionsRequestConfig(accountId: kotlin.String, afterLt: kotlin.Long?, beforeLt: kotlin.Long?, limit: kotlin.Int?, sortOrder: SortOrderGetBlockchainAccountTransactions?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (afterLt != null) {
                    put("after_lt", listOf(afterLt.toString()))
                }
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortOrder != null) {
                    put("sort_order", listOf(sortOrder.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}/transactions".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get blockchain block data
     * @param blockId block ID
     * @return BlockchainBlock
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainBlock(blockId: kotlin.String) : BlockchainBlock {
        val localVarResponse = getBlockchainBlockWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlock
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get blockchain block data
     * @param blockId block ID
     * @return ApiResponse<BlockchainBlock?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainBlockWithHttpInfo(blockId: kotlin.String) : ApiResponse<BlockchainBlock?> {
        val localVariableConfig = getBlockchainBlockRequestConfig(blockId = blockId)

        return request<Unit, BlockchainBlock>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainBlock
     *
     * @param blockId block ID
     * @return RequestConfig
     */
    fun getBlockchainBlockRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/blocks/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get transactions from block
     * @param blockId block ID
     * @return Transactions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainBlockTransactions(blockId: kotlin.String) : Transactions {
        val localVarResponse = getBlockchainBlockTransactionsWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get transactions from block
     * @param blockId block ID
     * @return ApiResponse<Transactions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainBlockTransactionsWithHttpInfo(blockId: kotlin.String) : ApiResponse<Transactions?> {
        val localVariableConfig = getBlockchainBlockTransactionsRequestConfig(blockId = blockId)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainBlockTransactions
     *
     * @param blockId block ID
     * @return RequestConfig
     */
    fun getBlockchainBlockTransactionsRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/blocks/{block_id}/transactions".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get blockchain config
     * @return BlockchainConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainConfig() : BlockchainConfig {
        val localVarResponse = getBlockchainConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get blockchain config
     * @return ApiResponse<BlockchainConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainConfigWithHttpInfo() : ApiResponse<BlockchainConfig?> {
        val localVariableConfig = getBlockchainConfigRequestConfig()

        return request<Unit, BlockchainConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainConfig
     *
     * @return RequestConfig
     */
    fun getBlockchainConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get blockchain config from a specific block, if present.
     * @param masterchainSeqno masterchain block seqno
     * @return BlockchainConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainConfigFromBlock(masterchainSeqno: kotlin.Int) : BlockchainConfig {
        val localVarResponse = getBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get blockchain config from a specific block, if present.
     * @param masterchainSeqno masterchain block seqno
     * @return ApiResponse<BlockchainConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<BlockchainConfig?> {
        val localVariableConfig = getBlockchainConfigFromBlockRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, BlockchainConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainConfigFromBlock
     *
     * @param masterchainSeqno masterchain block seqno
     * @return RequestConfig
     */
    fun getBlockchainConfigFromBlockRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/config".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all blocks in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain.  We don&#39;t recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
     * @param masterchainSeqno masterchain block seqno
     * @return BlockchainBlocks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainBlocks(masterchainSeqno: kotlin.Int) : BlockchainBlocks {
        val localVarResponse = getBlockchainMasterchainBlocksWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlocks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all blocks in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain.  We don&#39;t recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
     * @param masterchainSeqno masterchain block seqno
     * @return ApiResponse<BlockchainBlocks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainBlocksWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<BlockchainBlocks?> {
        val localVariableConfig = getBlockchainMasterchainBlocksRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, BlockchainBlocks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainMasterchainBlocks
     *
     * @param masterchainSeqno masterchain block seqno
     * @return RequestConfig
     */
    fun getBlockchainMasterchainBlocksRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/blocks".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get last known masterchain block
     * @return BlockchainBlock
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainHead() : BlockchainBlock {
        val localVarResponse = getBlockchainMasterchainHeadWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlock
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get last known masterchain block
     * @return ApiResponse<BlockchainBlock?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainHeadWithHttpInfo() : ApiResponse<BlockchainBlock?> {
        val localVariableConfig = getBlockchainMasterchainHeadRequestConfig()

        return request<Unit, BlockchainBlock>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainMasterchainHead
     *
     * @return RequestConfig
     */
    fun getBlockchainMasterchainHeadRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain-head",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get blockchain block shards
     * @param masterchainSeqno masterchain block seqno
     * @return BlockchainBlockShards
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainShards(masterchainSeqno: kotlin.Int) : BlockchainBlockShards {
        val localVarResponse = getBlockchainMasterchainShardsWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlockShards
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get blockchain block shards
     * @param masterchainSeqno masterchain block seqno
     * @return ApiResponse<BlockchainBlockShards?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainShardsWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<BlockchainBlockShards?> {
        val localVariableConfig = getBlockchainMasterchainShardsRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, BlockchainBlockShards>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainMasterchainShards
     *
     * @param masterchainSeqno masterchain block seqno
     * @return RequestConfig
     */
    fun getBlockchainMasterchainShardsRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/shards".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all transactions in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain. We don&#39;t recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
     * @param masterchainSeqno masterchain block seqno
     * @return Transactions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainTransactions(masterchainSeqno: kotlin.Int) : Transactions {
        val localVarResponse = getBlockchainMasterchainTransactionsWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all transactions in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain. We don&#39;t recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
     * @param masterchainSeqno masterchain block seqno
     * @return ApiResponse<Transactions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainTransactionsWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<Transactions?> {
        val localVariableConfig = getBlockchainMasterchainTransactionsRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainMasterchainTransactions
     *
     * @param masterchainSeqno masterchain block seqno
     * @return RequestConfig
     */
    fun getBlockchainMasterchainTransactionsRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/transactions".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get low-level information about an account taken directly from the blockchain.
     * @param accountId account ID
     * @return BlockchainRawAccount
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainRawAccount(accountId: kotlin.String) : BlockchainRawAccount {
        val localVarResponse = getBlockchainRawAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainRawAccount
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get low-level information about an account taken directly from the blockchain.
     * @param accountId account ID
     * @return ApiResponse<BlockchainRawAccount?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainRawAccountWithHttpInfo(accountId: kotlin.String) : ApiResponse<BlockchainRawAccount?> {
        val localVariableConfig = getBlockchainRawAccountRequestConfig(accountId = accountId)

        return request<Unit, BlockchainRawAccount>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainRawAccount
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun getBlockchainRawAccountRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get transaction data
     * @param transactionId transaction ID
     * @return Transaction
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainTransaction(transactionId: kotlin.String) : Transaction {
        val localVarResponse = getBlockchainTransactionWithHttpInfo(transactionId = transactionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transaction
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get transaction data
     * @param transactionId transaction ID
     * @return ApiResponse<Transaction?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainTransactionWithHttpInfo(transactionId: kotlin.String) : ApiResponse<Transaction?> {
        val localVariableConfig = getBlockchainTransactionRequestConfig(transactionId = transactionId)

        return request<Unit, Transaction>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainTransaction
     *
     * @param transactionId transaction ID
     * @return RequestConfig
     */
    fun getBlockchainTransactionRequestConfig(transactionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/transactions/{transaction_id}".replace("{"+"transaction_id"+"}", encodeURIComponent(transactionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get transaction data by message hash
     * @param msgId message ID
     * @return Transaction
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainTransactionByMessageHash(msgId: kotlin.String) : Transaction {
        val localVarResponse = getBlockchainTransactionByMessageHashWithHttpInfo(msgId = msgId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transaction
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get transaction data by message hash
     * @param msgId message ID
     * @return ApiResponse<Transaction?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainTransactionByMessageHashWithHttpInfo(msgId: kotlin.String) : ApiResponse<Transaction?> {
        val localVariableConfig = getBlockchainTransactionByMessageHashRequestConfig(msgId = msgId)

        return request<Unit, Transaction>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainTransactionByMessageHash
     *
     * @param msgId message ID
     * @return RequestConfig
     */
    fun getBlockchainTransactionByMessageHashRequestConfig(msgId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/messages/{msg_id}/transaction".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get blockchain validators
     * @return Validators
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainValidators() : Validators {
        val localVarResponse = getBlockchainValidatorsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Validators
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get blockchain validators
     * @return ApiResponse<Validators?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainValidatorsWithHttpInfo() : ApiResponse<Validators?> {
        val localVariableConfig = getBlockchainValidatorsRequestConfig()

        return request<Unit, Validators>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBlockchainValidators
     *
     * @return RequestConfig
     */
    fun getBlockchainValidatorsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/validators",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw blockchain config
     * @return RawBlockchainConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainConfig() : RawBlockchainConfig {
        val localVarResponse = getRawBlockchainConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RawBlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw blockchain config
     * @return ApiResponse<RawBlockchainConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainConfigWithHttpInfo() : ApiResponse<RawBlockchainConfig?> {
        val localVariableConfig = getRawBlockchainConfigRequestConfig()

        return request<Unit, RawBlockchainConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawBlockchainConfig
     *
     * @return RequestConfig
     */
    fun getRawBlockchainConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/config/raw",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw blockchain config from a specific block, if present.
     * @param masterchainSeqno masterchain block seqno
     * @return RawBlockchainConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainConfigFromBlock(masterchainSeqno: kotlin.Int) : RawBlockchainConfig {
        val localVarResponse = getRawBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RawBlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw blockchain config from a specific block, if present.
     * @param masterchainSeqno masterchain block seqno
     * @return ApiResponse<RawBlockchainConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<RawBlockchainConfig?> {
        val localVariableConfig = getRawBlockchainConfigFromBlockRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, RawBlockchainConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRawBlockchainConfigFromBlock
     *
     * @param masterchainSeqno masterchain block seqno
     * @return RequestConfig
     */
    fun getRawBlockchainConfigFromBlockRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/config/raw".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Send message to blockchain
     * @param sendBlockchainMessageRequest both a single boc and a batch of boc serialized in base64 are accepted
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendBlockchainMessage(sendBlockchainMessageRequest: SendBlockchainMessageRequest) : Unit {
        val localVarResponse = sendBlockchainMessageWithHttpInfo(sendBlockchainMessageRequest = sendBlockchainMessageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Send message to blockchain
     * @param sendBlockchainMessageRequest both a single boc and a batch of boc serialized in base64 are accepted
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sendBlockchainMessageWithHttpInfo(sendBlockchainMessageRequest: SendBlockchainMessageRequest) : ApiResponse<Unit?> {
        val localVariableConfig = sendBlockchainMessageRequestConfig(sendBlockchainMessageRequest = sendBlockchainMessageRequest)

        return request<SendBlockchainMessageRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendBlockchainMessage
     *
     * @param sendBlockchainMessageRequest both a single boc and a batch of boc serialized in base64 are accepted
     * @return RequestConfig
     */
    fun sendBlockchainMessageRequestConfig(sendBlockchainMessageRequest: SendBlockchainMessageRequest) : RequestConfig<SendBlockchainMessageRequest> {
        val localVariableBody = sendBlockchainMessageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/blockchain/message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Status
     * @return ServiceStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun status() : ServiceStatus {
        val localVarResponse = statusWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ServiceStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Status
     * @return ApiResponse<ServiceStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun statusWithHttpInfo() : ApiResponse<ServiceStatus?> {
        val localVariableConfig = statusRequestConfig()

        return request<Unit, ServiceStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation status
     *
     * @return RequestConfig
     */
    fun statusRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
