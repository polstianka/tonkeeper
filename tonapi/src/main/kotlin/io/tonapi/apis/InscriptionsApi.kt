/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.tonapi.models.AccountEvents
import io.tonapi.models.GetInscriptionOpTemplate200Response
import io.tonapi.models.InscriptionBalances
import io.tonapi.models.StatusDefaultResponse

import com.squareup.moshi.Json

import io.tonapi.infrastructure.ApiClient
import io.tonapi.infrastructure.ApiResponse
import io.tonapi.infrastructure.ClientException
import io.tonapi.infrastructure.ClientError
import io.tonapi.infrastructure.ServerException
import io.tonapi.infrastructure.ServerError
import io.tonapi.infrastructure.MultiValueMap
import io.tonapi.infrastructure.PartConfig
import io.tonapi.infrastructure.RequestConfig
import io.tonapi.infrastructure.RequestMethod
import io.tonapi.infrastructure.ResponseType
import io.tonapi.infrastructure.Success
import io.tonapi.infrastructure.toMultiValue

class InscriptionsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    /**
     * 
     * Get all inscriptions by owner address. It&#39;s experimental API and can be dropped in the future.
     * @param accountId account ID
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return InscriptionBalances
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountInscriptions(accountId: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0) : InscriptionBalances {
        val localVarResponse = getAccountInscriptionsWithHttpInfo(accountId = accountId, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InscriptionBalances
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all inscriptions by owner address. It&#39;s experimental API and can be dropped in the future.
     * @param accountId account ID
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return ApiResponse<InscriptionBalances?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountInscriptionsWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<InscriptionBalances?> {
        val localVariableConfig = getAccountInscriptionsRequestConfig(accountId = accountId, limit = limit, offset = offset)

        return request<Unit, InscriptionBalances>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountInscriptions
     *
     * @param accountId account ID
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return RequestConfig
     */
    fun getAccountInscriptionsRequestConfig(accountId: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/experimental/accounts/{account_id}/inscriptions".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the transfer inscriptions history for account. It&#39;s experimental API and can be dropped in the future.
     * @param accountId account ID
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return AccountEvents
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountInscriptionsHistory(accountId: kotlin.String, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, limit: kotlin.Int? = 100) : AccountEvents {
        val localVarResponse = getAccountInscriptionsHistoryWithHttpInfo(accountId = accountId, acceptLanguage = acceptLanguage, beforeLt = beforeLt, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the transfer inscriptions history for account. It&#39;s experimental API and can be dropped in the future.
     * @param accountId account ID
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return ApiResponse<AccountEvents?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountInscriptionsHistoryWithHttpInfo(accountId: kotlin.String, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, limit: kotlin.Int?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountInscriptionsHistoryRequestConfig(accountId = accountId, acceptLanguage = acceptLanguage, beforeLt = beforeLt, limit = limit)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountInscriptionsHistory
     *
     * @param accountId account ID
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return RequestConfig
     */
    fun getAccountInscriptionsHistoryRequestConfig(accountId: kotlin.String, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/experimental/accounts/{account_id}/inscriptions/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the transfer inscriptions history for account. It&#39;s experimental API and can be dropped in the future.
     * @param accountId account ID
     * @param ticker 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return AccountEvents
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountInscriptionsHistoryByTicker(accountId: kotlin.String, ticker: kotlin.String, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, limit: kotlin.Int? = 100) : AccountEvents {
        val localVarResponse = getAccountInscriptionsHistoryByTickerWithHttpInfo(accountId = accountId, ticker = ticker, acceptLanguage = acceptLanguage, beforeLt = beforeLt, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the transfer inscriptions history for account. It&#39;s experimental API and can be dropped in the future.
     * @param accountId account ID
     * @param ticker 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return ApiResponse<AccountEvents?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountInscriptionsHistoryByTickerWithHttpInfo(accountId: kotlin.String, ticker: kotlin.String, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, limit: kotlin.Int?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountInscriptionsHistoryByTickerRequestConfig(accountId = accountId, ticker = ticker, acceptLanguage = acceptLanguage, beforeLt = beforeLt, limit = limit)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountInscriptionsHistoryByTicker
     *
     * @param accountId account ID
     * @param ticker 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return RequestConfig
     */
    fun getAccountInscriptionsHistoryByTickerRequestConfig(accountId: kotlin.String, ticker: kotlin.String, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/experimental/accounts/{account_id}/inscriptions/{ticker}/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeGetInscriptionOpTemplate(val value: kotlin.String) {
         @Json(name = "ton20") ton20("ton20"),
         @Json(name = "gram20") gram20("gram20")
     }

    /**
     * enum for parameter operation
     */
     enum class OperationGetInscriptionOpTemplate(val value: kotlin.String) {
         @Json(name = "transfer") transfer("transfer")
     }

    /**
     * 
     * return comment for making operation with inscription. please don&#39;t use it if you don&#39;t know what you are doing
     * @param type 
     * @param operation 
     * @param amount 
     * @param ticker 
     * @param who 
     * @param destination  (optional)
     * @param comment  (optional)
     * @return GetInscriptionOpTemplate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getInscriptionOpTemplate(type: TypeGetInscriptionOpTemplate, operation: OperationGetInscriptionOpTemplate, amount: kotlin.String, ticker: kotlin.String, who: kotlin.String, destination: kotlin.String? = null, comment: kotlin.String? = null) : GetInscriptionOpTemplate200Response {
        val localVarResponse = getInscriptionOpTemplateWithHttpInfo(type = type, operation = operation, amount = amount, ticker = ticker, who = who, destination = destination, comment = comment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetInscriptionOpTemplate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * return comment for making operation with inscription. please don&#39;t use it if you don&#39;t know what you are doing
     * @param type 
     * @param operation 
     * @param amount 
     * @param ticker 
     * @param who 
     * @param destination  (optional)
     * @param comment  (optional)
     * @return ApiResponse<GetInscriptionOpTemplate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getInscriptionOpTemplateWithHttpInfo(type: TypeGetInscriptionOpTemplate, operation: OperationGetInscriptionOpTemplate, amount: kotlin.String, ticker: kotlin.String, who: kotlin.String, destination: kotlin.String?, comment: kotlin.String?) : ApiResponse<GetInscriptionOpTemplate200Response?> {
        val localVariableConfig = getInscriptionOpTemplateRequestConfig(type = type, operation = operation, amount = amount, ticker = ticker, who = who, destination = destination, comment = comment)

        return request<Unit, GetInscriptionOpTemplate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getInscriptionOpTemplate
     *
     * @param type 
     * @param operation 
     * @param amount 
     * @param ticker 
     * @param who 
     * @param destination  (optional)
     * @param comment  (optional)
     * @return RequestConfig
     */
    fun getInscriptionOpTemplateRequestConfig(type: TypeGetInscriptionOpTemplate, operation: OperationGetInscriptionOpTemplate, amount: kotlin.String, ticker: kotlin.String, who: kotlin.String, destination: kotlin.String?, comment: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.value))
                if (destination != null) {
                    put("destination", listOf(destination.toString()))
                }
                if (comment != null) {
                    put("comment", listOf(comment.toString()))
                }
                put("operation", listOf(operation.value))
                put("amount", listOf(amount.toString()))
                put("ticker", listOf(ticker.toString()))
                put("who", listOf(who.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/experimental/inscriptions/op-template",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
